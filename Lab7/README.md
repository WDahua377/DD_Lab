## 程式目的
實作 16-bit Carry Look-ahead Adder(CLA) 與 64-bit CLA，使用 4-bit Lookahead Carry Unit(LCU) 與 16-bit LCU 構成，計算隨機兩數`in_a`、`in_b`與隨機進位`cin`相加並檢查結果是否正確，共進行 9 次測試，最後將統計測試正確的次數。

### CLA 實作（64-bit）
1. `a`、`b`為兩個輸入訊號，將與當前的進位輸入訊號`cin`相加並將結果賦予結果輸出`sum`
2. 對`a`、`b`的每個位元，使用`gp_generator`生成`g`（進位生成信號）和`p`（進位傳遞信號）
3. 將`a`和`b`分成多個區塊，使用相同的模組逐步計算出每個區塊的進位`c`，並組合成更大的區塊：
    1. 將`a`和`b`分成 16 個 4 位元的區塊，使用`g`、`p`和`cin`計算區塊內部的進位（`c[3:1]`、`c[7:5]`...），並為每個區塊生成組生成信號`gG`與組傳播信號`gP`
    2. 將 4 個 4 位元的區塊視為一個局部（16 位元），使用`gG`、`gP`和`cin`計算局部內部的進位（`c[4]`、`c[8]`...），並為每個區塊生成組生成信號`GG`與組傳播信號`GP`
    3. 使用`GG`、`GP`和`cin`計算最高層級的進位（`c[16]`、`c[32]`...），完成所有進位`c`的計算
4. `sum_generator`使用`a`、`b`與前述所得進位結果`c`計算並輸出`sum` 

### Testbench 實作
1. 在`idx`的迴圈中，每次測試開始前，都會將重置信號`rst`設置為 1，此時程式將重置`in_a`、`in_b`與`cin`即將其設為 0，確保測試在相同條件下開始執行
2. 20ns 後`rst`被設為 0，此時測試開始，程式將計算`in_a`、`in_b`與`cin`相加的正確結果`correct_ans`
3. 等待一定的時鐘週期（即 `write == 9`）後，程式會比較正確結果`correct_ans`與 CLA 的輸出，判斷並顯示 CLA 結果的正確性
4. 共進行 9 次測試，最後將統計與顯示測試正確的次數